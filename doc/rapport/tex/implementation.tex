\section{Implémentation du compilateur}

\paragraph{}Classiquement durant la phase de vérification syntaxique, un compilateur créer un
arbre de syntaxe abstraite, qui est ensuite utiliser afin de réaliser la vérification sémantique.

%% PARLER DU MODE DE FONCTIONNEMENT DU PARSER + GRAMMAIRE LL

%% PARLER QUE TOUTEFOIS LES EXPRESSIONS SONT SOUS FORME D'ARBRE. (DONNER ALGORITHME DE CRÉATION ?)

\paragraph{}La vérification sémantique ce fait ensuite via l'aide des tables suivantes :

\begin{itemize}
 \item la table des lexicographique ou table des symboles
 \item la table des déclarations
 \item la table des représentations
 \item la table des régions
\end{itemize}

\paragraph{}Plutôt que d'utiliser 4 tables de la sorte nous avons opté pour une structure de contexte
plus proche de la signification sémantique directe du langage.
Il en résulte donc un code à la fois plus clair et plus simple à comprendre pour un oeil extérieur.

Ainsi le contexte contient deux membres: le programme et la fonction courrante, ce qui nous permet de 
gérer les portés des variables.

\paragraph{}Le programme contient toutes les déclarations globales comme les structures, les variables
et constantes globales, ainsi que les les functions et procédures.

\paragraph{}Les fonctions et procédures contiennent les parametres, les variables locales, ainsi que 
la liste d'instruction de la fonction et le type de retour pour les fonctions.

\paragraph{}On peut toutefois noter que le fait de se passer de la table des symboles peut entrainer 
une perte de performance du compilateur, l'interet de cette table étant en effet d'associer les 
différents identifieurs à un label (typiquement grâce à une table de hachage) permettant de les 
retrouver en un temps constant.

Dans notre cas, nous éxecutons une simple recherche dans un tableau,
la tâche est donc alourdie. En revanche, là où classiquement après avoir trouver l'identifieur, 
il faut examiner la table des déclarations pour connaitre son type et sa portée, 
nous connaissont déjà ces informations grâce aux structures utilisées.

\paragraph{}Le compilateur ezc ne fait donc qu'une passe pour effectuer les vérifications lexicale, 
syntaxique et sémantique d'un programme.

Par soucis de clareté dans le code, la phase de réécriture en langage intermédiaire (dans notre cas C++)
est elle réalisée lors d'un parcours du contexte généré lors de la première passe. On aurait cependant, très bien
pu imaginer n'effectuer qu'une seule et unique passe pour l'ensemble des étapes de compilations.

%% PARLER DE LA RÉÉCRITURE AVEC LES CLASSES CPP IMPLÉMENTÉE